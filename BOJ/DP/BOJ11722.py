# https://www.acmicpc.net/problem/11722

n = int(input().rstrip())
l = list(map(int, input().split()))
p = [0 for _ in range(n)]

for i in range(n):
    if i == 0:
        p[i] = 1
        continue
    cnt = 0
    for j in range(i):
        if l[j] > l[i] and p[j] > cnt:
            cnt = p[j]
    p[i] = cnt + 1

'''
p 리스트 채우는 과정 : 예시2
- 만약 주어진 입력이 "10 30 40 10 20 10" 이라고 가정하면
원소의 수만큼 p 리스트를 선언하고, 가장 첫 번째 값은 1로 초기화 ( 첫 번째 수는 자신보다 앞에 오는 수가 없어 수열을 형성하지 못하므로 무조건 길이 1인 수열임을 의미 )
- 그리고 두 번째 원소를 확인. 30은 10보다 큰 값이기 때문에 감소하는 부분수열을 형성할 수 없음. 따라서 수열의 길이 1을 p[1] = 1 로 초기화
- 다음 값인 40도 30과 마찬가지로 수열 형성 X. 따라서 p[2] = 1
- 다음 값인 10. 10은 자신보다 앞에 나오면서 작은 수가 30과 40이 있고
이 각각의 값은 p[i]값이 1임. 즉, 자신들보다 작으면서 앞에 나오는 값이 없었다는 의미.
이때 10이라는 수는 30 or 40 관계 없이 감소하는 수열을 형성할 수 있기 때문에 p[i] + 1(=2) 로 p[3] = 2 를 초기화

p 리스트 채우는 과정 : 예시2
- 만약 주어진 입력이 "10 30 10 20 20 10" 이라고 가정하면
원소의 수만큼 p 리스트를 선언하고, 가장 첫 번째 값은 1로 초기화 ( 첫 번째 수는 자신보다 앞에 오는 수가 없어 수열을 형성하지 못하므로 무조건 길이 1인 수열임을 의미 )
- 그리고 두 번째 원소를 확인. 30은 10보다 큰 값이기 때문에 감소하는 부분수열을 형성할 수 없음. 따라서 수열의 길이 1을 p[1] = 1 로 초기화
- 다음 값인 20은 자신보다 더 큰 값이 30에 앞에 존재하기 때문에 p[2] = p[1] + 1로 초기화
- 다음 값인 20. 20은 자신보다 더 큰 값이 30에 앞에 존재하기 때문에 p[3] = p[1] + 1로 초기화

- 마지막 값인 10. 10은 자신보다 앞에 나오면서 큰 값이 30, 20, 20이 존재함. 그중 가장 큰 p[i] 값은 2. 따라서 p[5] = 2 + 1로 초기화
- 즉, 자신보다 앞에 나오는 수가 더 크다는 것은 수열을 형성할 수 있다는 것을 의미하고, 그중 가장 큰 p[i] + 1로 초기화 한다는 것은 앞에 미리 계산된 부분 수열에 현재 수를 추가하겠다는 의미 
'''
print(max(p))
